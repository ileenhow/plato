<template>
  <div class="c-slider"
    @touchstart="dragstart"
    @touchmove="drag"
    @touchend="dragend">
    <div class="c-slider-content"
      :class="{transition: transition && !dragging & !slideReady}"
      :style="{transform: 'translate3d(' + offset + 'px, 0, 0 )'}"
      ref="content">
      <slot></slot>
    </div>
    <div class="c-slider-indicators" v-if="slideCount > 1">
      <i class="c-slider-indicator"
        v-for="i in slideCount"
        :class="{active: i - 1 === currIndex}"></i>
    </div>
  </div>
</template>

<script>
import { isHorizontal } from './utils/direction'

const classes = {
  prev: 'c-slider-prev',
  active: 'c-slider-active',
  next: 'c-slider-next'
}

export default {
  props: {
    index: {
      type: Number,
      default: 0,
      validator (val) {
        return val >= 0
      }
    },
    // 自动播放间隔秒数
    interval: {
      type: Number,
      default: 0,
      validator (val) {
        return val >= 0
      }
    },
    // 如果启用，延迟 200ms
    transition: {
      type: Boolean,
      default: false
    },
    // 灵敏度，数值越大，短距离快速滑动时越容易触发切换
    sensitivity: {
      type: Number,
      default: 0.2
    }
  },

  data () {
    return {
      slideCount: 0,
      currIndex: 0,
      offset: 0,
      dragging: false,
      // 就位，已经切换到目标位置，指示可以进行后续操作，比如重设位置
      slideReady: false
    }
  },

  computed: {
    prevIndex () {
      return this.slideCount ? (this.slideCount + this.currIndex - 1) % this.slideCount : -1
    },
    nextIndex () {
      return this.slideCount ? (this.currIndex + 1) % this.slideCount : -1
    }
  },

  mounted () {
    this.currIndex = this.index
    this.reset()
    this.automate()
  },

  updated () {
    this.reset()
  },

  watch: {
    index (val) {
      this.currIndex = val
    },
    prevIndex (val, old) {
      this.slideCount && old !== -1 && this.children[old].classList.remove(classes.prev)
      this.slideCount && val !== -1 && this.children[val].classList.add(classes.prev)
    },
    currIndex (val, old) {
      // this.slideReady = true
      this.slideCount && this.children[old].classList.remove(classes.active)
      this.slideCount && this.children[val].classList.add(classes.active)
    },
    nextIndex (val, old) {
      this.slideCount && old !== -1 && this.children[old].classList.remove(classes.next)
      this.slideCount && val !== -1 && this.children[val].classList.add(classes.next)
    },
    interval () {
      this.automate()
    }
  },

  methods: {
    reset () {
      if (this.maxOffset === 0 || this.slideCount !== this.$refs.content.children.length) {
        this.offset = 0
        this.maxOffset = this.$el.clientWidth
        this.minOffset = -this.maxOffset
        this.children = this.$refs.content.children
        this.slideCount = this.children.length
        if (this.slideCount) {
          this.children[this.currIndex].classList.add(classes.active)
        }
      }
    },
    automate () {
      if (this.interval) {
        if (!this.intervalId) {
          this.intervalId = setInterval(() => {
            if (!this.dragging && this.slideCount > 1) {
              this.slideReady = false
              this.offset = this.minOffset
              this.delay(this.nextIndex)
            }
          }, this.interval * 1000)
        }
      } else {
        if (this.intervalId) {
          clearInterval(this.intervalId)
        }
      }
    },
    dragstart (e) {
      if (this.slideCount > 1 && !this.dragging && e.touches && e.touches.length === 1) {
        this.dragging = true
        this.isHorizontal = false
        this.slideReady = false
        this.timeStamp = e.timeStamp
        this.start = e.touches[0]
        this.startX = e.touches[0].pageX - this.offset
      }
    },
    drag (e) {
      if (this.dragging) {
        // only slide while swipe horizontal
        if (this.isHorizontal || isHorizontal(e.touches[0], this.start)) {
          this.isHorizontal = true
          e.preventDefault()
          e.stopPropagation()
          const offset = Math.min(this.maxOffset, Math.max(this.minOffset, e.touches[0].pageX - this.startX))
          if (this.offset === 0 || offset * this.offset < -1) {
            if (offset < 0) {
              this.children[this.nextIndex].classList.remove(classes.prev)
            } else if (offset > 0) {
              this.children[this.prevIndex].classList.remove(classes.next)
            }
          }
          this.offset = offset
        } else {
          this.dragging = false
          this.isHorizontal = false
          this.slideReady = true
          this.offset = 0
        }
      }
    },
    dragend (e) {
      if (this.dragging) {
        this.dragging = false
        this.isHorizontal = false
        const distance = this.offset / (e.timeStamp - this.timeStamp) * 1000 * this.sensitivity
        if (this.offset > 0) {
          if (Math.max(distance, this.offset) > this.maxOffset / 2) {
            this.offset = this.maxOffset
            return this.delay(this.prevIndex)
          }
        } else if (this.offset < 0) {
          if (Math.min(distance, this.offset) < this.minOffset / 2) {
            this.offset = this.minOffset
            return this.delay(this.nextIndex)
          }
        }
        this.offset = 0
        this.delay(this.currIndex)
      }
    },
    delay (index) {
      this.transition ? setTimeout(() => {
        this.go(index)
      }, 200) : this.go(index)
    },
    go (index) {
      this.slideReady = false
      this.$nextTick(() => {
        this.offset = 0
        if (index !== this.currIndex) {
          this.currIndex = index
          this.$emit('slide', this.currIndex)
        }
        this.slideReady = true
      })
    }
  }
}
</script>

<style src="styles/components/core/slider"></style>
